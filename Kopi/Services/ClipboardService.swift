import AppKit

struct ClipboardContent {
    let contentType: String    // "text", "url", "image", "file", "html", "rtf", "color"
    let textContent: String?   // 文本内容 / 文件路径 / hex 颜色值
    let blobData: Data?        // 图片 / RTF / HTML 原始数据
    let sourceApp: String?     // 来源应用 bundle identifier
}

@MainActor
final class ClipboardService {
    static let shared = ClipboardService()

    private let pasteboard = NSPasteboard.general

    private static let concealedType = NSPasteboard.PasteboardType("org.nspasteboard.ConcealedType")
    private static let transientType = NSPasteboard.PasteboardType("org.nspasteboard.TransientType")
    private static let autoGeneratedType = NSPasteboard.PasteboardType("org.nspasteboard.AutoGeneratedType")
    private static let colorType = NSPasteboard.PasteboardType("com.apple.cocoa.pasteboard.color")
    private static let filenamesType = NSPasteboard.PasteboardType("NSFilenamesPboardType")
    private static let finderNodeType = NSPasteboard.PasteboardType("com.apple.finder.noderef")

    private static let imageExtensions: Set<String> = ["png", "jpg", "jpeg", "gif", "tiff", "tif", "bmp", "webp", "heic"]

    private init() {}

    var currentChangeCount: Int {
        pasteboard.changeCount
    }

    // MARK: - Legacy

    func readText() -> String? {
        pasteboard.string(forType: .string)
    }

    // MARK: - New Multi-Type Read

    func readContent() -> ClipboardContent? {
        let types = pasteboard.types ?? []

        // Filter: skip concealed / transient / auto-generated
        if types.contains(Self.concealedType)
            || types.contains(Self.transientType)
            || types.contains(Self.autoGeneratedType) {
            return nil
        }

        let sourceApp = NSWorkspace.shared.frontmostApplication?.bundleIdentifier

        // 1. Finder file copy — detected by NSFilenamesPboardType or com.apple.finder.noderef
        //    Must check BEFORE .tiff, because Finder also puts a .tiff icon on the pasteboard.
        if types.contains(Self.filenamesType) || types.contains(Self.finderNodeType) {
            if let fileURL = resolveFileURL(from: types) {
                // If the file is an image, load actual content from disk
                if Self.imageExtensions.contains(fileURL.pathExtension.lowercased()) {
                    if let imageData = loadImageData(from: fileURL) {
                        return ClipboardContent(contentType: "image", textContent: nil, blobData: imageData, sourceApp: sourceApp)
                    }
                }
                return ClipboardContent(contentType: "file", textContent: fileURL.path, blobData: nil, sourceApp: sourceApp)
            }
        }

        // 2. Direct image data on pasteboard (screenshot to clipboard, copy from Preview, etc.)
        //    Only reaches here if NOT a Finder file copy.
        if types.contains(.png) || types.contains(.tiff) {
            var imageData: Data?
            if types.contains(.png) {
                imageData = pasteboard.data(forType: .png)
            }
            if imageData == nil, types.contains(.tiff),
               let tiffData = pasteboard.data(forType: .tiff) {
                if let rep = NSBitmapImageRep(data: tiffData) {
                    imageData = rep.representation(using: .png, properties: [:])
                } else if let nsImage = NSImage(data: tiffData),
                          let tiffRep = nsImage.tiffRepresentation,
                          let bitmapRep = NSBitmapImageRep(data: tiffRep) {
                    imageData = bitmapRep.representation(using: .png, properties: [:])
                }
            }
            if let imageData {
                return ClipboardContent(contentType: "image", textContent: nil, blobData: imageData, sourceApp: sourceApp)
            }
        }

        // 3. File URL (non-Finder source, e.g. drag from other apps)
        if types.contains(.fileURL) {
            if let fileURL = resolveFileURL(from: types) {
                if Self.imageExtensions.contains(fileURL.pathExtension.lowercased()) {
                    if let imageData = loadImageData(from: fileURL) {
                        return ClipboardContent(contentType: "image", textContent: nil, blobData: imageData, sourceApp: sourceApp)
                    }
                }
                return ClipboardContent(contentType: "file", textContent: fileURL.path, blobData: nil, sourceApp: sourceApp)
            }
        }

        // 4. RTF
        if types.contains(.rtf),
           let rtfData = pasteboard.data(forType: .rtf) {
            let plainText = pasteboard.string(forType: .string)
            return ClipboardContent(contentType: "rtf", textContent: plainText, blobData: rtfData, sourceApp: sourceApp)
        }

        // 5. HTML — convert to Markdown for content, keep raw HTML in blobData
        if types.contains(.html),
           let htmlData = pasteboard.data(forType: .html) {
            let htmlString = String(data: htmlData, encoding: .utf8)
                ?? String(data: htmlData, encoding: .unicode)
                ?? ""
            let markdown = HTMLToMarkdown.shared.convert(htmlString)
            let plainText = pasteboard.string(forType: .string)
            let textContent = markdown ?? plainText
            return ClipboardContent(contentType: "html", textContent: textContent, blobData: htmlData, sourceApp: sourceApp)
        }

        // 6. Color
        if types.contains(Self.colorType),
           let colorData = pasteboard.data(forType: Self.colorType) {
            if let color = try? NSKeyedUnarchiver.unarchivedObject(ofClass: NSColor.self, from: colorData) {
                let rgb = color.usingColorSpace(.sRGB) ?? color
                let hex = String(format: "#%02X%02X%02X",
                                 Int(rgb.redComponent * 255),
                                 Int(rgb.greenComponent * 255),
                                 Int(rgb.blueComponent * 255))
                return ClipboardContent(contentType: "color", textContent: hex, blobData: nil, sourceApp: sourceApp)
            }
        }

        // 7. Plain text / URL
        if let text = pasteboard.string(forType: .string), !text.isEmpty {
            let contentType = detectContentType(text)
            return ClipboardContent(contentType: contentType, textContent: text, blobData: nil, sourceApp: sourceApp)
        }

        return nil
    }

    // MARK: - File URL Resolution

    private func resolveFileURL(from types: [NSPasteboard.PasteboardType]) -> URL? {
        // Method 1: NSFilenamesPboardType — most reliable for Finder copies, gives direct path
        if types.contains(Self.filenamesType),
           let filenames = pasteboard.propertyList(forType: Self.filenamesType) as? [String],
           let firstPath = filenames.first {
            return URL(fileURLWithPath: firstPath)
        }

        // Method 2: readObjects with NSURL — resolves file reference URLs to real paths
        if let urls = pasteboard.readObjects(forClasses: [NSURL.self], options: [
            .urlReadingFileURLsOnly: true
        ]) as? [URL], let url = urls.first {
            return url
        }

        // Method 3: Read .fileURL as property list string
        if types.contains(.fileURL),
           let urlString = pasteboard.propertyList(forType: .fileURL) as? String,
           let url = URL(string: urlString),
           url.isFileURL {
            // This might be a file reference URL (file:///.file/id=...), try to resolve it
            if let resolved = (url as NSURL).filePathURL {
                return resolved
            }
            return url
        }

        return nil
    }

    // MARK: - Image Loading

    private func loadImageData(from url: URL) -> Data? {
        guard let data = try? Data(contentsOf: url) else { return nil }
        // If already PNG, use directly
        if url.pathExtension.lowercased() == "png" { return data }
        // Otherwise convert to PNG for consistent storage
        guard let nsImage = NSImage(data: data),
              let tiffRep = nsImage.tiffRepresentation,
              let bitmapRep = NSBitmapImageRep(data: tiffRep),
              let pngData = bitmapRep.representation(using: .png, properties: [:]) else {
            return data // fallback: store original format
        }
        return pngData
    }

    // MARK: - Write

    func writeText(_ text: String) {
        pasteboard.clearContents()
        pasteboard.setString(text, forType: .string)
    }

    func writeContent(_ item: ClipboardItem) {
        pasteboard.clearContents()
        switch item.contentType {
        case "image":
            if let data = item.blobData {
                pasteboard.setData(data, forType: .png)
            }
        case "file":
            let url = URL(fileURLWithPath: item.content)
            pasteboard.writeObjects([url as NSURL])
        case "html":
            if let blobData = item.blobData {
                pasteboard.setData(blobData, forType: .html)
            }
            if !item.content.isEmpty {
                pasteboard.setString(item.content, forType: .string)
            }
        case "rtf":
            if let blobData = item.blobData {
                pasteboard.setData(blobData, forType: .rtf)
            }
            if !item.content.isEmpty {
                pasteboard.setString(item.content, forType: .string)
            }
        default:
            pasteboard.setString(item.content, forType: .string)
        }
    }

    func detectContentType(_ text: String) -> String {
        let trimmed = text.trimmingCharacters(in: .whitespacesAndNewlines)
        if let url = URL(string: trimmed), url.scheme != nil, url.host != nil {
            return "url"
        }
        return "text"
    }

    // MARK: - Thumbnail Generation

    static func generateThumbnail(from imageData: Data, maxSize: CGFloat = 64) -> Data? {
        guard let image = NSImage(data: imageData) else { return nil }
        let originalSize = image.size
        guard originalSize.width > 0, originalSize.height > 0 else { return nil }

        let scale = min(maxSize / originalSize.width, maxSize / originalSize.height, 1.0)
        let newSize = NSSize(width: originalSize.width * scale, height: originalSize.height * scale)

        let thumbnailImage = NSImage(size: newSize)
        thumbnailImage.lockFocus()
        image.draw(in: NSRect(origin: .zero, size: newSize),
                   from: NSRect(origin: .zero, size: originalSize),
                   operation: .copy,
                   fraction: 1.0)
        thumbnailImage.unlockFocus()

        guard let tiffRep = thumbnailImage.tiffRepresentation,
              let bitmapRep = NSBitmapImageRep(data: tiffRep) else { return nil }
        return bitmapRep.representation(using: .png, properties: [:])
    }
}
